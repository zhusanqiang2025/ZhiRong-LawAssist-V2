import{g as c,l as o}from"./index-Dlmv2mUC.js";class a{static instance=null;ws=null;taskId=null;token=null;callbacks={};reconnectAttempts=0;maxReconnectAttempts=5;reconnectDelay=1e3;heartbeatInterval=null;isConnecting=!1;isConnected=!1;get wsUrl(){return`${c()}/api/v1/tasks/ws`}constructor(){}static getInstance(){return a.instance||(a.instance=new a),a.instance}async connect(s,t,n){if(this.isConnected&&this.taskId===s){o.websocket("Already connected to the same task");return}this.disconnect(),this.taskId=s,this.token=t,this.callbacks=n||{};try{await this.connectWithRetry()}catch(e){console.error("Failed to connect to WebSocket:",e),this.callbacks.onError&&this.callbacks.onError("WebSocket连接失败")}}async connectWithRetry(){if(!this.isConnecting){for(this.isConnecting=!0;this.reconnectAttempts<this.maxReconnectAttempts;)try{await this.createConnection();return}catch(s){this.reconnectAttempts++,console.warn(`WebSocket connection attempt ${this.reconnectAttempts} failed:`,s),this.reconnectAttempts<this.maxReconnectAttempts&&await this.delay(this.reconnectDelay*this.reconnectAttempts)}throw this.isConnecting=!1,new Error(`Failed to connect after ${this.maxReconnectAttempts} attempts`)}}async createConnection(){return new Promise((s,t)=>{try{if(!this.taskId||!this.token)throw new Error("Task ID and token are required");const n=`${this.wsUrl}/${this.taskId}?token=${encodeURIComponent(this.token)}`;o.websocket("Connecting to WebSocket:",n),this.ws=new WebSocket(n),this.ws.onopen=()=>{o.websocket("WebSocket connected successfully"),this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.startHeartbeat(),this.callbacks.onConnected&&this.callbacks.onConnected(),s()},this.ws.onmessage=e=>{this.handleMessage(e.data)},this.ws.onclose=e=>{o.websocket("WebSocket disconnected:",{code:e.code,reason:e.reason}),this.isConnected=!1,this.isConnecting=!1,this.stopHeartbeat(),this.callbacks.onDisconnected&&this.callbacks.onDisconnected(),e.code!==1e3&&this.reconnectAttempts<this.maxReconnectAttempts&&setTimeout(()=>{this.connectWithRetry().catch(console.error)},this.reconnectDelay*(this.reconnectAttempts+1))},this.ws.onerror=e=>{console.error("WebSocket error:",e),this.isConnecting=!1,this.reconnectAttempts===0&&t(e)}}catch(n){this.isConnecting=!1,t(n)}})}handleMessage(s){try{const t=JSON.parse(s);switch(console.log("[WebSocket Service] 收到消息:",t.type,t),t.type){case"task_status":case"task_progress":if(t.data&&this.callbacks.onProgress){const n={taskId:t.data.task_id,status:t.data.current_node||t.data.status||"processing",progress:t.data.progress||0,currentNode:t.data.message||t.data.current_node||"",nodeProgress:t.data.node_progress||{},workflowSteps:(t.data.workflow_steps||[]).map(e=>({...e,estimatedTime:e.estimated_time})),estimatedTimeRemaining:t.data.estimated_time_remaining,errorMessage:t.data.error_message,timestamp:t.timestamp};this.callbacks.onProgress(n)}break;case"task_completed":console.log("[WebSocket] 收到 task_completed 消息:",t),this.callbacks.onCompleted&&t.data?(console.log("[WebSocket] 调用 onCompleted 回调，result:",t.data.result),this.callbacks.onCompleted(t.data.result)):console.error("[WebSocket] onCompleted 回调缺失或 message.data 为空",{hasCallback:!!this.callbacks.onCompleted,hasData:!!t.data,data:t.data});break;case"task_error":this.callbacks.onError&&t.message&&this.callbacks.onError(t.message);break;case"pong":console.debug("Received pong");break;case"error":this.callbacks.onError&&t.message&&this.callbacks.onError(t.message);break;default:console.warn("Unknown message type:",t.type)}}catch(t){console.error("Error parsing WebSocket message:",t)}}sendMessage(s){if(this.ws&&this.isConnected)try{this.ws.send(JSON.stringify(s))}catch(t){console.error("Error sending WebSocket message:",t)}else console.warn("WebSocket is not connected")}ping(){this.sendMessage({type:"ping"})}requestStatus(){this.sendMessage({type:"get_status"})}startHeartbeat(){this.stopHeartbeat(),this.heartbeatInterval=setInterval(()=>{this.ping()},3e4)}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null)}disconnect(){this.stopHeartbeat(),this.ws&&(this.ws.close(1e3,"Client disconnect"),this.ws=null),this.isConnected=!1,this.isConnecting=!1,this.taskId=null,this.token=null,this.callbacks={},this.reconnectAttempts=0}getConnectionStatus(){return{isConnected:this.isConnected,isConnecting:this.isConnecting,taskId:this.taskId}}delay(s){return new Promise(t=>setTimeout(t,s))}destroy(){this.disconnect(),a.instance=null}}const r=a.getInstance(),l=()=>r.getConnectionStatus();export{l as g,r as t};
