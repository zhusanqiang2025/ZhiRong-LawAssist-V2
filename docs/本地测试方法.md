# 本地测试方法

## 飞书集成本地开发 - 功能测试完整指南

---

## 一、Token 管理测试

### 测试 1：直接调用 Token 管理工具

```bash
# 进入 backend 容器
docker-compose -f docker-compose.local.yml exec backend bash

# 启动 Python 测试
python -c "
from app.utils.token_manager import get_valid_token, clear_token_cache

# 测试获取 Token
print('=== 测试 1: 获取有效 Token ===')
token = get_valid_token()
print(f'Token 长度: {len(token)}')
print(f'Token 前 50 字符: {token[:50]}...')

# 测试重复获取（应使用缓存）
print('\n=== 测试 2: 重复获取 Token（应使用缓存）===')
token2 = get_valid_token()
print(f'Token 是否相同: {token == token2}')

# 测试清除缓存
print('\n=== 测试 3: 清除缓存后重新获取 ===')
clear_token_cache()
token3 = get_valid_token()
print(f'新 Token 长度: {len(token3)}')

print('\n=== 所有测试完成！===')
"
```

**预期输出：**
```
=== 测试 1: 获取有效 Token ===
[INFO] 成功获取 access_token
Token 长度: 235
Token 前 50 字符: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

=== 测试 2: 重复获取 Token（应使用缓存）===
Token 是否相同: True

=== 测试 3: 清除缓存后重新获取 ===
[INFO] 已从 Redis 删除 Token
[INFO] 正在调用登录接口获取 Token
新 Token 长度: 235

=== 所有测试完成！===
```

### 测试 2：通过 Swagger 接口测试

1. 浏览器访问：http://localhost:8000/docs
2. 找到 `POST /api/v1/auth/login` 接口
3. 点击 "Try it out"
4. 输入系统服务账号信息：
   ```json
   {
     "username": "zhusanqiang@az028.cn",
     "password": "你的密码"
   }
   ```
5. 点击 "Execute"
6. 检查返回的 `access_token`

---

## 二、飞书 API 测试

### 测试 1：获取 Tenant Access Token

```bash
# 进入 backend 容器
docker-compose -f docker-compose.local.yml exec backend bash

# 测试获取 tenant_access_token
python -c "
from app.utils.feishu_api import get_tenant_access_token

print('=== 测试: 获取飞书 Tenant Access Token ===')
token = get_tenant_access_token()
print(f'Token 长度: {len(token)}')
print(f'Token 前 50 字符: {token[:50]}...')
print('测试完成！')
"
```

**预期输出：**
```
=== 测试: 获取飞书 Tenant Access Token ===
[INFO] 成功获取 tenant_access_token，有效期: 7200 秒
Token 长度: 128
Token 前 50 字符: t-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
测试完成！
```

### 测试 2：获取多维表数据（需配置多维表信息）

```bash
# 进入 backend 容器
docker-compose -f docker-compose.local.yml exec backend bash

# 替换以下变量为实际的值
python -c "
from app.utils.feishu_api import get_base_table_data

print('=== 测试: 获取多维表数据 ===')

# 替换为实际的多维表信息
app_token = 'your_app_token'
table_id = 'your_table_id'

try:
    data = get_base_table_data(app_token, table_id, page_size=10)
    records = data.get('data', {}).get('items', [])
    print(f'成功获取 {len(records)} 条记录')
    print(f'第一条记录: {records[0] if records else \"无数据\"}')
except Exception as e:
    print(f'获取失败: {e}')

print('测试完成！')
"
```

### 测试 3：发送飞书文本消息

```bash
# 进入 backend 容器
docker-compose -f docker-compose.local.yml exec backend bash

# 替换以下变量为实际的值
python -c "
from app.utils.feishu_api import send_feishu_text_msg

print('=== 测试: 发送飞书文本消息 ===')

# 替换为实际的接收者 ID
user_id = 'your_user_id'  # 如 ou_xxxxxxxxxxxxxxxx

try:
    result = send_feishu_text_msg(
        user_id,
        content='您好，这是飞书集成本地开发的测试消息'
    )
    print(f'消息发送成功: {result}')
except Exception as e:
    print(f'消息发送失败: {e}')

print('测试完成！')
"
```

---

## 三、飞书回调接口测试

### 测试 1：健康检查接口

```bash
curl http://localhost:8000/api/v1/feishu/callback/test
```

**预期响应：**
```json
{
  "status": "ok",
  "message": "飞书回调接口正常工作",
  "endpoints": [
    "/api/v1/feishu/callback/position - 立场选择回调",
    "/api/v1/feishu/callback/url-verification - URL 验证",
    "/api/v1/feishu/callback/test - 测试接口"
  ],
  "config": {
    "encrypt_key_configured": true,
    "verification_token_configured": true
  }
}
```

### 测试 2：URL 验证接口

```bash
curl -X POST http://localhost:8000/api/v1/feishu/callback/url-verification \
  -H "Content-Type: application/json" \
  -d "{\"token\":\"your_token\",\"challenge\":\"test_challenge\"}"
```

**预期响应：**
```json
{
  "challenge": "test_challenge"
}
```

### 测试 3：立场选择回调接口（模拟飞书回调）

```bash
curl -X POST http://localhost:8000/api/v1/feishu/callback/position \
  -H "Content-Type: application/json" \
  -d '{
    "token": "test_token",
    "timestamp": "1234567890",
    "nonce": "test_nonce",
    "event": {
      "operator": {
        "user_id": "ou_test_user_id"
      },
      "action": {
        "value": "approve"
      }
    }
  }'
```

**预期响应：**
```json
{
  "code": 0,
  "msg": "success"
}
```

**日志输出：**
```
[INFO] 收到飞书立场选择回调
[INFO] 解析结果: 用户 ID=ou_test_user_id, 立场选择=approve
[INFO] 用户 ou_test_user_id 选择了「通过」立场
[INFO] 飞书立场选择回调处理成功
```

---

## 四、Celery 定时任务测试

### 测试 1：手动触发 Token 刷新任务

```bash
# 进入 backend 容器
docker-compose -f docker-compose.local.yml exec backend bash

# 启动 Celery Worker（在新终端）
celery -A app.tasks.celery_app worker --loglevel=info

# 触发任务（在另一个终端）
python -c "
from app.tasks.feishu_integration_tasks import refresh_feishu_integration_token

print('=== 测试: 手动触发 Token 刷新任务 ===')
result = refresh_feishu_integration_token.delay()
print(f'任务已提交，Task ID: {result.id}')

# 等待任务完成
import time
time.sleep(5)

# 获取任务结果
task_result = result.get()
print(f'任务执行结果: {task_result}')

print('测试完成！')
"
```

**预期输出：**
```
=== 测试: 手动触发 Token 刷新任务 ===
任务已提交，Task ID: xxx-xxx-xxx
[INFO] 开始执行飞书集成 Token 刷新任务
[INFO] access_token 刷新成功
任务执行结果: {
  "status": "success",
  "token_length": 235,
  "message": "飞书集成 Token 刷新成功"
}
测试完成！
```

### 测试 2：定时任务自动执行

1. 启动 Celery Beat：
```bash
docker-compose -f docker-compose.local.yml exec backend celery -A app.tasks.celery_app beat --loglevel=info
```

2. 观察定时任务日志（默认每 90 分钟执行一次）：
```
[INFO] Scheduler: Sending due task feishu-integration-token-refresh
```

---

## 五、Swagger 文档测试

### 完整测试流程

1. **访问 Swagger 文档**
   - 浏览器打开：http://localhost:8000/docs
   - 找到「Feishu Integration (Local)」分组

2. **测试 GET /api/v1/feishu/callback/test**
   - 点击 "Try it out"
   - 点击 "Execute"
   - 检查响应结果

3. **测试 POST /api/v1/feishu/callback/url-verification**
   - 点击 "Try it out"
   - 输入测试数据：
     ```json
     {
       "token": "test_token",
       "challenge": "test_challenge"
     }
     ```
   - 点击 "Execute"
   - 检查响应是否包含 `challenge`

4. **测试 POST /api/v1/feishu/callback/position**
   - 点击 "Try it out"
   - 输入测试数据（参考上文）
   - 点击 "Execute"
   - 检查响应是否为 `{"code": 0, "msg": "success"}`

---

## 六、飞书开放平台配置测试

### 步骤 1：配置飞书测试应用

1. 登录 [飞书开放平台](https://open.feishu.cn)
2. 创建测试应用
3. 获取 App ID 和 App Secret
4. 配置事件回调：
   - 回调地址：`https://your-domain.com/api/v1/feishu/callback/position`
   - 订阅事件：选择需要的事件类型（如 `application.bot.menu_v6`）

### 步骤 2：配置内网穿透

```bash
# 使用 ngrok
ngrok http 8000

# 获取公网地址，如：https://xxx.ngrok.io
```

### 步骤 3：测试飞书回调

1. 在飞书开放平台发送测试事件
2. 检查本地日志：
```bash
docker-compose -f docker-compose.local.yml logs -f backend
```
3. 查看是否收到回调日志

---

## 七、错误排查测试

### 测试 1：Redis 连接失败场景

```bash
# 停止 Redis 容器
docker-compose -f docker-compose.local.yml stop redis

# 测试 Token 管理是否自动降级到内存存储
python -c "
from app.utils.token_manager import get_valid_token
token = get_valid_token()
print(f'Redis 不可用时，Token 仍可获取: {len(token)} 字符')
"

# 恢复 Redis 容器
docker-compose -f docker-compose.local.yml start redis
```

### 测试 2：错误密码场景

```bash
# 临时修改 .env 中的密码为错误值
# 观察错误处理是否正常
```

### 测试 3：网络超时场景

```bash
# 模拟网络延迟（需要修改代码中的 timeout 参数）
# 观察重试机制是否生效
```

---

## 八、测试清单

- [ ] Token 管理工具测试通过
- [ ] 飞书 Tenant Token 获取成功
- [ ] 飞书回调接口响应正常
- [ ] Celery 任务执行成功
- [ ] Swagger 文档可访问
- [ ] 飞书开放平台回调接收成功

---

**测试完成后，飞书集成功能即可投入使用！**
